# -*- coding: utf-8 -*-
"""
Runtime Hook Template
=====================

Centralized template for the Ren'Py runtime translation hook.

Architecture Notes (v4.1.0 — DIRECT COMPARISON):
    Ren'Py's text rendering pipeline (confirmed from renpy/ast.py Say.execute):

        1. say_menu_text_filter  — raw string, BEFORE translation & [var] interpolation
        2. Translation lookup    — translate strings: old/new blocks
        3. Substitution          — [variable] interpolation via py_eval()
        4. Tokenization          — splits text into TEXT and TAG tokens
        5. replace_text          — called on each TEXT fragment AFTER tag splitting
        6. Custom text tags      — applied to tokens

    CRITICAL SAFETY RULE:
        say_menu_text_filter receives text BEFORE [variable] interpolation.
        Any partial modification (keyword/substring replacement, punct spacing)
        can corrupt bracket expressions like [GAME.ship.name], causing
        SyntaxError in renpy.python.py_eval(). This was the root cause of
        ALL production crashes reported in v2.7.0/v2.7.1.

        config.replace_text receives text AFTER interpolation and tag splitting.
        At this point, [variables] are already resolved to their values and
        {tags} have been removed.

    DIRECT COMPARISON APPROACH (v4.1.0):
        Layer 1: say_menu_text_filter — EXACT DICT LOOKUP ONLY (zero partial mods)
        Layer 2: replace_text        — Direct comparison (exact + case-insensitive)
        Layer 3: character_callback   — Debug monitoring only

    v4.1.0 CHANGE: Replaced Trie-based Word/Substring processors with direct
    string comparison from strings.json. The trie processors caused widespread
    text corruption by matching short keys (e.g. "An"->"bir", "NOT"->"OLUMSUZ",
    "MA"->"yüksek lisans") inside already-translated target-language text.
"""

# RenLocalizer Runtime Translation Hook Template (v4.1.0)
# Uses Centralized Template System for easier updates.
RUNTIME_HOOK_TEMPLATE = r'''# RenLocalizer Runtime Translation Hook v4.1.0
# Direct comparison translation system.
#
# ARCHITECTURE (v4.1.0 — DIRECT COMPARISON):
#   Layer 1: say_menu_text_filter — EXACT match only (pre-interpolation safety)
#   Layer 2: replace_text — Direct comparison from strings.json (post-interpolation)
#   Layer 3: character_callback — Debug monitoring
#
# KEY DESIGN PRINCIPLE (v4.1.0):
#   Uses ONLY exact + case-insensitive exact match against strings.json.
#   No Trie-based Word/Substring processors that caused text corruption
#   by matching short keys inside longer already-translated text.
#
# Loads translations from strings.json.
# Generated by RenLocalizer.

init -999 python:
    import os as _rl_os
    import io as _rl_io
    import re as _rl_re
    import json as _rl_json

    # =========================================================================
    # INITIALIZATION (v4.1.0 — DIRECT COMPARISON)
    # =========================================================================
    _rl_translated_values = set()
    _renlocalizer_debug = False
    _rl_translations = {{}}
    _rl_translations_ci = {{}}     # Case-insensitive: lower_key -> value (v4.1.0)
    _rl_loaded = False
    _rl_prev_say_menu_filter = None
    _rl_prev_replace_text = None

    # Punct spacing regex — used ONLY in Layer 2 (post-interpolation)
    # so no bracket/tag protection is needed.
    _rl_punct_space_re = _rl_re.compile(
        r"([.!?;:])(?![\s\.\!\?,;:\)\]\}}])(?=[A-Za-z0-9\u00C0-\u024F\u0370-\u03FF\u0400-\u04FF])"
    )

    def _rl_fix_punct_spacing(text):
        """Add space after punctuation stuck to next word.

        SAFE: This is only called from Layer 2 (replace_text) where text
        has already been interpolated and tag-split. No bracket expressions
        or text tags exist in the input.
        """
        if not text:
            return text
        return _rl_punct_space_re.sub(r"\1 ", text)

    def _rl_apply_case(original, replacement):
        """Smart case preservation: match the case pattern of the original."""
        if not original or not replacement or len(replacement) < 1:
            return replacement
        if original.isupper():
            return replacement.upper()
        elif original.islower():
            return replacement.lower()
        elif len(original) > 0 and original[0].isupper():
            if not replacement[0].isupper():
                return replacement[0].upper() + replacement[1:]
        elif len(original) > 0 and original[0].islower():
            if replacement[0].isupper():
                return replacement[0].lower() + replacement[1:]
        return replacement

    def _rl_find_strings_json():
        """Find strings.json with exhaustive path search."""
        lang = "{renpy_lang}"
        try:
            if hasattr(_preferences, 'language') and _preferences.language:
                lang = _preferences.language
        except Exception:
            pass

        candidates = []
        if hasattr(config, 'gamedir') and config.gamedir:
            gd = config.gamedir
            candidates.append(_rl_os.path.join(gd, "tl", lang, "strings.json"))
            candidates.append(_rl_os.path.join(gd, "tl", lang, "strings.json").replace("\\\\", "/"))
            candidates.append(_rl_os.path.join(gd, "tl", lang, "strings.json").replace("/", "\\\\"))

        if hasattr(renpy, 'config') and hasattr(renpy.config, 'searchpath') and renpy.config.searchpath:
            for d in renpy.config.searchpath:
                candidates.append(_rl_os.path.join(d, "tl", lang, "strings.json"))
                candidates.append(_rl_os.path.join(d, "tl", lang, "strings.json").replace("\\\\", "/"))
                candidates.append(_rl_os.path.join(d, "tl", lang, "strings.json").replace("/", "\\\\"))

        candidates.extend([
            _rl_os.path.join("game", "tl", lang, "strings.json"),
            _rl_os.path.join("tl", lang, "strings.json"),
            "/tl/" + lang + "/strings.json",
        ])

        for path in candidates:
            try:
                full = _rl_os.path.abspath(path) if not _rl_os.path.isabs(path) else path
                if _rl_os.path.isfile(full):
                    return full
            except Exception:
                pass

        # Android APK support
        if hasattr(renpy, 'android') and renpy.android:
            try:
                if hasattr(renpy, 'loader') and hasattr(renpy.loader, 'game_apks') and len(renpy.loader.game_apks) > 0:
                    filename = "tl/" + lang + "/strings.json"
                    apk = renpy.loader.game_apks[0]
                    xname = "x-" + "/x-".join(filename.split("/"))
                    binary = apk.open(xname)
                    if binary is not None:
                        return "__APK__:" + filename
            except Exception:
                pass

        return None

    def _rl_load_translations():
        global _rl_translations, _rl_translations_ci, _rl_loaded, _rl_translated_values

        json_path = _rl_find_strings_json()
        if not json_path:
            return False

        try:
            data = None
            if json_path.startswith("__APK__:"):
                fname = json_path[8:]
                xname = "x-" + "/x-".join(fname.split("/"))
                apk = renpy.loader.game_apks[0]
                binary = apk.open(xname)
                if binary:
                    data = binary.getvalue().decode("utf-8")
            else:
                with _rl_io.open(json_path, "r", encoding="utf-8") as f:
                    data = f.read()

            if not data:
                return False

            _rl_translations = _rl_json.loads(data)

            # v4.1.0 DIRECT COMPARISON: Build simple lookup dicts only.
            # No Trie-based Word/Substring processors — they caused
            # widespread text corruption by matching short keys like
            # "An", "NOT", "MA", "INT" inside longer translated text.
            _rl_translations_ci = {{}}
            _rl_translated_values = set()
            _rl_ci_conflicts = set()  # Track ambiguous lower-case keys

            for k, v in _rl_translations.items():
                if k and v and k.strip() and v.strip() and k.strip() != v.strip():
                    clean_k = k.strip()
                    clean_v = v.strip()
                    _rl_translated_values.add(clean_v)
                    lower_k = clean_k.lower()
                    if lower_k in _rl_ci_conflicts:
                        pass  # Already marked ambiguous — skip
                    elif lower_k in _rl_translations_ci:
                        if _rl_translations_ci[lower_k] != clean_v:
                            # Same key different translations (e.g. "Skip"->"Geç", "skip"->"atla")
                            # Remove from CI dict to prevent wrong translation.
                            # Exact case-sensitive lookup still works for both.
                            _rl_ci_conflicts.add(lower_k)
                            del _rl_translations_ci[lower_k]
                    else:
                        _rl_translations_ci[lower_k] = clean_v

            del _rl_ci_conflicts  # Free memory

            _rl_loaded = True
            return True
        except Exception:
            return False

    # Load translations at startup
    if not _rl_load_translations():
        # SAFETY: Do NOT call renpy.notify() during init phase!
        # renpy.notify() shows the "notify" screen which gets added to scene_lists.
        # During init, ui.stack is empty, so any later context copy that tries to
        # remove the notify screen (via config.context_copy_remove_screens) will
        # crash with IndexError in renpy.ui.detached().
        # Instead, silently log to file if possible.
        try:
            import os as _rl_init_os
            _rl_log_path = _rl_init_os.path.join(
                config.gamedir if hasattr(config, 'gamedir') and config.gamedir else ".",
                "renlocalizer_init.log"
            )
            with open(_rl_log_path, "a", encoding="utf-8") as _rl_f:
                _rl_f.write("RenLocalizer: strings.json not found. Runtime translation disabled.\n")
        except Exception:
            pass

    # =========================================================================
    # LAYER 1: say_menu_text_filter — EXACT DICT LOOKUP ONLY
    # =========================================================================
    # SAFETY CRITICAL: This runs BEFORE [variable] interpolation (py_eval).
    # We MUST NOT partially modify text here. Only exact dict lookup is safe.
    #
    # Pipeline: Say.execute() -> say_menu_text_filter(what) -> ... -> py_eval()
    # If we corrupt [GAME.ship.name] here, py_eval() will SyntaxError crash.
    #
    # The ONLY operation performed is: _rl_translations.get(text)
    # If no exact match, text passes through 100% unchanged.

    def _rl_say_menu_text_filter(text):
        """Exact-match-only filter. NEVER partially modifies text."""
        try:
            if text and _rl_loaded:
                # Try 1: Exact match (preserves tags, whitespace, everything)
                translated = _rl_translations.get(text)
                # Try 2: Whitespace-trimmed match
                if translated is None:
                    stripped = text.strip()
                    if stripped:
                        translated = _rl_translations.get(stripped)
                        if translated is not None:
                            # Preserve original leading/trailing whitespace
                            leading = text[:len(text) - len(text.lstrip())]
                            trailing = text[len(text.rstrip()):]
                            translated = leading + translated + trailing
                # Try 3: Quote-wrapped text — some games (e.g. play_dialogue)
                # wrap vary() output in literal quotes: renpy.say(speaker, '"'+talk+'"')
                # Strip outer quotes for lookup, re-wrap translation if found.
                if translated is None and len(text) >= 3:
                    _t = text.strip()
                    if len(_t) >= 3 and _t[0] == '"' and _t[-1] == '"':
                        _inner = _t[1:-1]
                        if _inner:
                            translated = _rl_translations.get(_inner)
                            if translated is None:
                                translated = _rl_translations.get(_inner.strip())
                            if translated is not None:
                                # Re-wrap in quotes to preserve game formatting
                                translated = '"' + translated + '"'

                # Apply if found
                if translated is not None:
                    if _renlocalizer_debug:
                        try:
                            with _rl_io.open(_rl_os.path.join(config.gamedir, "renlocalizer_debug.log"), "a", encoding="utf-8") as f:
                                f.write(u"[L1_EXACT] {{}} -> {{}}\n".format(repr(text), repr(translated)))
                        except Exception:
                            pass
                    text = translated
        except Exception:
            pass  # On ANY error, return original text unchanged

        # Chain to any previous filter
        if _rl_prev_say_menu_filter:
            try:
                return _rl_prev_say_menu_filter(text)
            except Exception:
                pass
        return text

    # =========================================================================
    # LAYER 2: replace_text — DIRECT COMPARISON (v4.1.0)
    # =========================================================================
    # This receives TEXT fragments AFTER [variable] interpolation and
    # AFTER {tag} splitting. No bracket expressions or text tags remain.
    #
    # v4.1.0 uses ONLY direct comparison against strings.json:
    #   1. Exact match (case-sensitive)
    #   2. Case-insensitive exact match
    #   3. Punctuation spacing
    #
    # Example: "Hello {b}World{/b}!" calls replace_text 3 times:
    #   replace_text("Hello "), replace_text("World"), replace_text("!")

    def _rl_replace_text(text):
        """Direct comparison translation on post-interpolation text fragments.

        v4.1.0: Uses ONLY exact and case-insensitive exact match against
        strings.json entries. No Trie-based Word/Substring processors.
        This eliminates all false-positive matching corruption where short
        keys like 'An', 'NOT', 'MA' would match inside longer words.
        """
        try:
            if not text or not _rl_loaded:
                if _rl_prev_replace_text:
                    return _rl_prev_replace_text(text)
                return text

            result = text
            _stripped = text.strip()

            # 0. Skip already-translated text (performance + safety)
            if _stripped and _stripped in _rl_translated_values:
                result = _rl_fix_punct_spacing(text)
                if _rl_prev_replace_text:
                    result = _rl_prev_replace_text(result)
                return result

            translated = None

            # 1. Exact match — case-sensitive (highest priority)
            translated = _rl_translations.get(text)
            if translated is None and _stripped:
                translated = _rl_translations.get(_stripped)
                if translated is not None:
                    leading = text[:len(text) - len(text.lstrip())]
                    trailing = text[len(text.rstrip()):]
                    translated = leading + translated + trailing

            # 2. Case-insensitive exact match (v4.1.0 direct comparison)
            if translated is None and _stripped:
                ci_value = _rl_translations_ci.get(_stripped.lower())
                if ci_value is not None:
                    translated = _rl_apply_case(_stripped, ci_value)
                    leading = text[:len(text) - len(text.lstrip())]
                    trailing = text[len(text.rstrip()):]
                    translated = leading + translated + trailing

            # 3. Quote-wrapped text (play_dialogue compatibility)
            # Some games wrap vary() output in literal quotes:
            #   renpy.say(speaker, '"' + vary(text) + '"')
            # After tag splitting, replace_text receives '"segment"'.
            # Strip outer quotes for lookup, re-wrap if found.
            if translated is None and _stripped and len(_stripped) >= 3:
                if _stripped[0] == '"' and _stripped[-1] == '"':
                    _inner = _stripped[1:-1]
                    if _inner:
                        # Try exact match on inner text
                        translated = _rl_translations.get(_inner)
                        # Try case-insensitive on inner text
                        if translated is None:
                            _ci_inner = _rl_translations_ci.get(_inner.lower())
                            if _ci_inner is not None:
                                translated = _rl_apply_case(_inner, _ci_inner)
                        if translated is not None:
                            # Re-wrap in quotes to preserve game dialogue formatting
                            translated = '"' + translated + '"'
                            leading = text[:len(text) - len(text.lstrip())]
                            trailing = text[len(text.rstrip()):]
                            translated = leading + translated + trailing

            if translated is not None:
                result = translated

            # 3. Punctuation spacing (safe — no brackets/tags in fragments)
            result = _rl_fix_punct_spacing(result)

            if _renlocalizer_debug and result != text:
                try:
                    with _rl_io.open(_rl_os.path.join(config.gamedir, "renlocalizer_debug.log"), "a", encoding="utf-8") as f:
                        f.write(u"[L2_REPLACE] {{}} -> {{}}\n".format(repr(text), repr(result)))
                except Exception:
                    pass

            # Chain to any previous replace_text handler
            if _rl_prev_replace_text:
                result = _rl_prev_replace_text(result)

            return result
        except Exception:
            if _rl_prev_replace_text:
                try:
                    return _rl_prev_replace_text(text)
                except Exception:
                    pass
            return text

    # =========================================================================
    # LAYER 3: Character callback (debug monitoring only)
    # =========================================================================
    def _rl_character_callback(event, interact=True, what=None, **kwargs):
        """Monitors dialogue for debugging."""
        if not _renlocalizer_debug or event != "begin" or not what:
            return
        try:
            with _rl_io.open(_rl_os.path.join(config.gamedir, "renlocalizer_debug.log"), "a", encoding="utf-8") as f:
                f.write(u"[L3_DIALOGUE] event={{}} what={{}}\n".format(event, repr(what)))
        except Exception:
            pass

    # =========================================================================
    # DEBUG FUNCTIONS
    # =========================================================================
    def _rl_toggle_debug():
        global _renlocalizer_debug
        _renlocalizer_debug = not _renlocalizer_debug
        renpy.notify("RenLocalizer Debug: " + ("ON" if _renlocalizer_debug else "OFF"))

    def _rl_force_language():
        renpy.change_language("{renpy_lang}")
        renpy.notify("Language forced to: {renpy_lang}")
        _rl_load_translations()
        renpy.restart_interaction()

    def _rl_reload_translations():
        if _rl_load_translations():
            renpy.notify("RenLocalizer: Translations reloaded!")
        else:
            renpy.notify("RenLocalizer: Failed to reload translations!")
        renpy.restart_interaction()

init 999 python:
    # Install hooks late so game scripts (e.g., emoji filters) don't overwrite us.
    # We chain any existing handlers we find at this point.
    global _rl_prev_say_menu_filter, _rl_prev_replace_text

    _rl_prev_say_menu_filter = config.say_menu_text_filter
    config.say_menu_text_filter = _rl_say_menu_text_filter

    _rl_prev_replace_text = config.replace_text
    config.replace_text = _rl_replace_text

    if not hasattr(config, 'all_character_callbacks'):
        config.all_character_callbacks = []
    if _rl_character_callback not in config.all_character_callbacks:
        config.all_character_callbacks.append(_rl_character_callback)
'''
